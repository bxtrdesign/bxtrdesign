<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>bxtr.design</title>
  <link rel="stylesheet" href="style.css">

  <style>
    /* Fullscreen overlay for fade effect */
    #fadeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s ease;
      z-index: 9999;
    }
  </style>

  <script>
    function redirectWithFade() {
      const overlay = document.getElementById("fadeOverlay");
      overlay.style.opacity = "1"; // fade in
      setTimeout(() => {
        window.location.href = "https://bxtrdesign.com/home";
      }, 1000); // wait for fade (1s)
    }

    document.addEventListener("click", redirectWithFade);
  </script>
</head>
<body>
  <div id="fadeOverlay"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script>

// --- Configurable parameters ---
const baseWidth = 1920;        // reference width for density
const baseCellSize = 16;       // target cell size at baseline width
const minCellSize = 8;         // minimum cell size (prevents unreadable detail on small screens)
let highlightRadius = 300.0;   // How far the circular highlight reaches
let highlightFalloff = 0.7;    // Exponent controlling fade toward edges
// --------------------------------

let asciiVideo;
let asciiShader;
let videoReady = false;

let asciiPalette = " bxtrBXTR.,'*+;:>";

let atlasGraphics;
const atlasCharSize = 64;

let cols, rows;
let scaledVideoWidth, scaledVideoHeight;
let offsetX, offsetY;
let videoAspect;

function preload() {
  asciiVideo = createVideo("bxtr.mp4");
  asciiVideo.hide();
  asciiVideo.volume(0);
}

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();
  textFont("monospace");

  // Sort palette by brightness
  asciiPalette = sortPaletteByBrightness(asciiPalette, atlasCharSize);

  // Generate ASCII atlas
  atlasGraphics = createGraphics(asciiPalette.length * atlasCharSize, atlasCharSize);
  atlasGraphics.background(0);
  atlasGraphics.fill(255);
  atlasGraphics.textAlign(LEFT, TOP);
  atlasGraphics.textSize(atlasCharSize);
  for (let i = 0; i < asciiPalette.length; i++) {
    atlasGraphics.text(asciiPalette[i], i * atlasCharSize, 0);
  }

  const vertShader = `
    precision mediump float;
    attribute vec3 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition.xy * 0.5 + 0.5;
      gl_Position = vec4(aPosition, 1.0);
    }
  `;

  const fragShader = `
    precision mediump float;
    uniform sampler2D uVideo;
    uniform sampler2D uAtlas;
    uniform vec2 uResolution;
    uniform vec2 uMouse;
    uniform float uRadius;
    uniform float uFalloff;
    uniform float uCols;
    uniform float uRows;
    uniform float uNumChars;
    uniform vec2 uVideoScale;
    uniform vec2 uVideoOffset;
    varying vec2 vTexCoord;

    void main() {
      vec2 fragPos = vec2(gl_FragCoord.x, uResolution.y - gl_FragCoord.y);

      // Cell calculations
      vec2 cellSize = vec2(uVideoScale.x / uCols, uVideoScale.y / uRows);
      vec2 cell = floor((fragPos - uVideoOffset) / cellSize);
      vec2 cellOrigin = cell * cellSize + uVideoOffset;
      vec2 cellUV = (fragPos - cellOrigin) / cellSize;

      // Sample video at cell center
      vec2 videoPixelPos = cellOrigin + 0.5 * cellSize - uVideoOffset;
      vec2 videoUV = videoPixelPos / uVideoScale;
      videoUV = clamp(videoUV, 0.0, 1.0);
      vec4 videoColor = texture2D(uVideo, videoUV);

      float brightness = (videoColor.r + videoColor.g + videoColor.b) / 3.0;
      float idx = floor((1.0 - brightness) * (uNumChars - 1.0));

      // Atlas sampling for character
      vec2 uvAtlas = vec2((idx + cellUV.x) / uNumChars, cellUV.y);
      vec4 atlasColor = texture2D(uAtlas, uvAtlas);

      // Highlight per cell
      vec2 cellCenter = cellOrigin + 0.5 * cellSize;
      float distToMouse = distance(cellCenter, uMouse);
      float highlightFactor = clamp(1.0 - distToMouse / uRadius, 0.0, 1.0);
      highlightFactor = pow(highlightFactor, uFalloff);

      vec4 highlightColor = vec4(videoColor.rgb, 1.0);
      vec4 finalColor = mix(vec4(videoColor.rgb * atlasColor.rgb, 1.0), highlightColor, highlightFactor);

      gl_FragColor = finalColor;
    }
  `;

  asciiShader = createShader(vertShader, fragShader);

  asciiVideo.elt.onloadedmetadata = () => {
    asciiVideo.loop();
    asciiVideo.play();
    videoReady = true;
    videoAspect = asciiVideo.width / asciiVideo.height;
    console.log("Video loaded, shader ready. Aspect ratio: " + videoAspect);
    updateVideoScaling();
  };
}

function updateVideoScaling() {
  const canvasAspect = width / height;
  if(canvasAspect > videoAspect){
    scaledVideoHeight = height;
    scaledVideoWidth = height * videoAspect;
  } else {
    scaledVideoWidth = width;
    scaledVideoHeight = width / videoAspect;
  }

  // Center video
  offsetX = (width - scaledVideoWidth) / 2.0;
  offsetY = (height - scaledVideoHeight) / 2.0;

  // ðŸ”§ Dynamic density scaling
  let scaledCellSize = baseCellSize * (width / baseWidth);
  scaledCellSize = max(scaledCellSize, minCellSize);

  cols = floor(scaledVideoWidth / scaledCellSize);
  rows = floor(scaledVideoHeight / scaledCellSize);
}

function sortPaletteByBrightness(palette, sampleSize = 64){
  const tempCanvas = createGraphics(sampleSize, sampleSize);
  tempCanvas.textSize(sampleSize);
  tempCanvas.textAlign(CENTER, CENTER);
  tempCanvas.background(0);

  const brightnessValues = [];
  for(let i=0;i<palette.length;i++){
    tempCanvas.background(0);
    tempCanvas.fill(255);
    tempCanvas.text(palette[i], sampleSize/2, sampleSize/2);
    tempCanvas.loadPixels();
    let total = 0;
    for(let px of tempCanvas.pixels) total += brightness(px);
    brightnessValues.push(total/tempCanvas.pixels.length);
  }

  const paired = palette.split('').map((c,i)=>[c,brightnessValues[i]]);
  paired.sort((a,b)=>a[1]-b[1]);
  return paired.map(p=>p[0]).join('');
}

function draw() {
  if (!videoReady) return;

  shader(asciiShader);

  asciiShader.setUniform("uMouse", [mouseX, mouseY]);
  asciiShader.setUniform("uVideo", asciiVideo);
  asciiShader.setUniform("uAtlas", atlasGraphics.get());
  asciiShader.setUniform("uResolution", [width, height]);
  asciiShader.setUniform("uRadius", highlightRadius);
  asciiShader.setUniform("uFalloff", highlightFalloff);
  asciiShader.setUniform("uCols", cols);
  asciiShader.setUniform("uRows", rows);
  asciiShader.setUniform("uNumChars", asciiPalette.length);
  asciiShader.setUniform("uVideoScale", [scaledVideoWidth, scaledVideoHeight]);
  asciiShader.setUniform("uVideoOffset", [offsetX, offsetY]);

  beginShape(TRIANGLE_STRIP);
  vertex(-1, -1, 0);
  vertex(1, -1, 0);
  vertex(-1, 1, 0);
  vertex(1, 1, 0);
  endShape();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  updateVideoScaling();
}

</script>
</body>
</html>
