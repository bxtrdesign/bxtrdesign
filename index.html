<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>bxtr.design</title>
  <link rel="stylesheet" href="style.css">

  <style>
    #fadeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s ease;
      z-index: 9999;
    }
  </style>

  <script>
    function redirectWithFade() {
      const overlay = document.getElementById("fadeOverlay");
      overlay.style.opacity = "1";
      setTimeout(() => {
        window.location.href = "https://bxtrdesign.com/home";
      }, 1000);
    }
    document.addEventListener("click", redirectWithFade);
  </script>
</head>
<body>
  <div id="fadeOverlay"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script>

const baseWidth = 1920;
const baseCellSize = 16;
const minCellSize = 8;
let highlightRadius = 300.0;
let highlightFalloff = 0.7;

let asciiVideo;
let asciiShader;
let videoReady = false;
let asciiPalette = " bxtrBXTR.,'*+;:>";
let atlasGraphics;
const atlasCharSize = 64;

let cols, rows, scaledVideoWidth, scaledVideoHeight, offsetX, offsetY, videoAspect;

// Detect mobile
const isMobile = /Mobi|Android/i.test(navigator.userAgent);

function preload() {
  // Mobile-friendly video setup
  asciiVideo = createVideo("bxtr.mp4", () => {
    asciiVideo.hide();
    asciiVideo.loop();
    asciiVideo.volume(0);
  });
  asciiVideo.elt.muted = true; // critical for mobile autoplay
}

function setup() {
  if(isMobile){
    createCanvas(windowWidth, windowHeight); // fallback 2D canvas
    background(0); 
    fill(255);
    textSize(32);
    textAlign(CENTER, CENTER);
    text("Mobile video shader unsupported", width/2, height/2);
    return;
  }

  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();
  textFont("monospace");

  // Sort palette
  asciiPalette = sortPaletteByBrightness(asciiPalette, atlasCharSize);

  // ASCII atlas
  atlasGraphics = createGraphics(asciiPalette.length * atlasCharSize, atlasCharSize);
  atlasGraphics.background(0);
  atlasGraphics.fill(255);
  atlasGraphics.textAlign(LEFT, TOP);
  atlasGraphics.textSize(atlasCharSize);
  for(let i=0;i<asciiPalette.length;i++){
    atlasGraphics.text(asciiPalette[i], i*atlasCharSize,0);
  }

  const vertShader = `
    precision highp float;
    attribute vec3 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition.xy * 0.5 + 0.5;
      gl_Position = vec4(aPosition, 1.0);
    }
  `;

  const fragShader = `
    precision highp float;
    uniform sampler2D uVideo;
    uniform sampler2D uAtlas;
    uniform vec2 uResolution;
    uniform vec2 uMouse;
    uniform float uRadius;
    uniform float uFalloff;
    uniform float uCols;
    uniform float uRows;
    uniform float uNumChars;
    uniform vec2 uVideoScale;
    uniform vec2 uVideoOffset;
    varying vec2 vTexCoord;

    void main() {
      vec2 fragPos = vec2(gl_FragCoord.x, uResolution.y - gl_FragCoord.y);
      vec2 cellSize = vec2(uVideoScale.x/uCols, uVideoScale.y/uRows);
      vec2 cell = floor((fragPos - uVideoOffset)/cellSize);
      vec2 cellOrigin = cell*cellSize + uVideoOffset;
      vec2 cellUV = (fragPos - cellOrigin)/cellSize;
      vec2 videoPixelPos = cellOrigin + 0.5*cellSize - uVideoOffset;
      vec2 videoUV = clamp(videoPixelPos / uVideoScale, 0.0,1.0);
      vec4 videoColor = texture2D(uVideo, videoUV);
      float brightness = (videoColor.r+videoColor.g+videoColor.b)/3.0;
      float idx = floor((1.0-brightness)*(uNumChars-1.0));
      vec2 uvAtlas = vec2((idx+cellUV.x)/uNumChars, cellUV.y);
      vec4 atlasColor = texture2D(uAtlas, uvAtlas);
      vec2 cellCenter = cellOrigin + 0.5*cellSize;
      float distToMouse = distance(cellCenter,uMouse);
      float highlightFactor = clamp(1.0-distToMouse/uRadius,0.0,1.0);
      highlightFactor = pow(highlightFactor,uFalloff);
      vec4 highlightColor = vec4(videoColor.rgb,1.0);
      vec4 finalColor = mix(vec4(videoColor.rgb*atlasColor.rgb,1.0),highlightColor,highlightFactor);
      gl_FragColor = finalColor;
    }
  `;

  asciiShader = createShader(vertShader, fragShader);

  asciiVideo.elt.onloadedmetadata = () => {
    asciiVideo.loop();
    asciiVideo.play();
    videoReady = true;
    videoAspect = asciiVideo.width / asciiVideo.height;
    updateVideoScaling();
  };
}

function updateVideoScaling() {
  const canvasAspect = width / height;
  if(canvasAspect>videoAspect){
    scaledVideoHeight = height;
    scaledVideoWidth = height * videoAspect;
  } else {
    scaledVideoWidth = width;
    scaledVideoHeight = width / videoAspect;
  }
  offsetX = (width - scaledVideoWidth)/2.0;
  offsetY = (height - scaledVideoHeight)/2.0;
  let scaledCellSize = baseCellSize*(width/baseWidth);
  scaledCellSize = max(scaledCellSize,minCellSize);
  cols = floor(scaledVideoWidth/scaledCellSize);
  rows = floor(scaledVideoHeight/scaledCellSize);
}

function sortPaletteByBrightness(palette,sampleSize=64){
  const tempCanvas = createGraphics(sampleSize,sampleSize);
  tempCanvas.textSize(sampleSize);
  tempCanvas.textAlign(CENTER,CENTER);
  tempCanvas.background(0);
  const brightnessValues=[];
  for(let i=0;i<palette.length;i++){
    tempCanvas.background(0);
    tempCanvas.fill(255);
    tempCanvas.text(palette[i], sampleSize/2, sampleSize/2);
    tempCanvas.loadPixels();
    let total=0;
    for(let px of tempCanvas.pixels) total+=brightness(px);
    brightnessValues.push(total/tempCanvas.pixels.length);
  }
  const paired = palette.split('').map((c,i)=>[c,brightnessValues[i]]);
  paired.sort((a,b)=>a[1]-b[1]);
  return paired.map(p=>p[0]).join('');
}

function draw() {
  if(isMobile) return; // fallback already drawn
  if(!videoReady) return;

  shader(asciiShader);
  asciiShader.setUniform("uMouse",[mouseX,mouseY]);
  asciiShader.setUniform("uVideo",asciiVideo);
  asciiShader.setUniform("uAtlas",atlasGraphics.get());
  asciiShader.setUniform("uResolution",[width,height]);
  asciiShader.setUniform("uRadius",highlightRadius);
  asciiShader.setUniform("uFalloff",highlightFalloff);
  asciiShader.setUniform("uCols",cols);
  asciiShader.setUniform("uRows",rows);
  asciiShader.setUniform("uNumChars",asciiPalette.length);
  asciiShader.setUniform("uVideoScale",[scaledVideoWidth,scaledVideoHeight]);
  asciiShader.setUniform("uVideoOffset",[offsetX,offsetY]);

  beginShape(TRIANGLE_STRIP);
  vertex(-1,-1,0);
  vertex(1,-1,0);
  vertex(-1,1,0);
  vertex(1,1,0);
  endShape();
}

function windowResized(){
  resizeCanvas(windowWidth,windowHeight);
  if(!isMobile) updateVideoScaling();
}
  </script>
</body>
</html>
